# Repository Guidelines

## Project Structure & Module Organisation

- Source code: `src/` (entry: `src/app.ts`), shared types in `src/types/`.
- Build output: `dist/` (generated by `tsc`).
- Config: `tsconfig.json`, package scripts in `package.json`.
- Tests: not yet configured; prefer `tests/` with `*.spec.ts`.

## Build, Test, and Development Commands

- Install dependencies: `npm ci` (or `npm install` for local development).
- Build TypeScript: `npm run build` (emits to `dist/`).
- Run compiled app: `npm start` (executes `node dist/app.js`).
- Quick dev run (no build): `npx ts-node src/app.ts`.
- Tests: `npm test` currently a placeholder; see Testing Guidelines to add real tests.

## Coding Style & Naming Conventions

- TypeScript strict mode enabled; favour explicit types at module boundaries.
- Indentation: 2 spaces; include semicolons; single quotes or consistent style.
- Naming: `camelCase` for variables/functions, `PascalCase` for types/classes, `UPPER_SNAKE_CASE` for constants.
- File names: `kebab-case.ts` (e.g., `user-service.ts`); index files allowed for small barrels.
- Imports: relative within `src/`; avoid deep relative chains by reorganising modules rather than path aliases.
- Prefer `const`; use `let` only when you need to reassign the reference (even if you mutate properties).
- All the code, all comments, all variables, etc. must be written in British English.

## Validation, Typing, and Routing

- Validate all external input with Zod. Schemas live in `src/schemas/` (e.g., `src/schemas/player.ts`, `src/schemas/match.ts`, `src/schemas/import.ts`). Extend there when adding new endpoints.
- Use `validateRequest` middleware from `src/middleware/validate.ts` to parse/validate `body`/`query`/`params`; prefer `safeParse` + middleware-level errors over inline `if` checks.
- Routes are factories under `src/routes/` exposing `createXRouter` (players, clubs, seasons, teams, matches, game-events, health, import, insights, dashboard). Inject dependencies for tests; default export wires real deps.
- Keep controllers/services/repositories typed: reuse Prisma types at boundaries, domain DTOs in services, and Zod-inferred types from schemas when consuming request data.
- Keep code readable and short: use semantic names for helpers and data (e.g., `parsePagination`, `mapMatchIssue`), extract repeated logical blocks into small functions, and avoid inline logic in controllers/routes. Reuse helpers in tests to keep cases descriptive.
- When adding new state logic (e.g., match locking, timers, score calculations), encapsulate it in named helpers/strategies and validate via Zod schemas; map errors to reusable constants/strings to avoid "magic" literals.
- For batch inputs (imports, assignments), validate the container and then each item with the same schemas as normal endpoints; do not return a global 400 for a single error: accumulate per-item errors with consistent messages.
- Optimise Prisma queries: use `select` to return only required fields (avoid deep `include`) and, if needed, create specific helpers/repositories for read views. When you need multiple existence checks, prefer a single `findMany` with `in` or a constrained `select` over multiple calls. Document `select` expectations in tests.

## Engineering Principles

- As a pragmatic engineer follow SOLID principles; keep modules small, cohesive, and loosely coupled.
- Prefer established design patterns where they clarify intent (e.g., Strategy, Factory, Dependency Injection).
- All new code must include unit tests; update or add tests when modifying behaviour.
- Verify all new features are covered by tests.
- Do not accept a feature as complete until all tests pass.
- Add intent comments sparingly to capture why code is shaped this way (functional rationale, engineering trade-offs, chosen flows), so readers understand decisions when revisiting.
- Frontend: any new UI text must come from the translation file (`frontend/src/i18n/translations.ts`) and be consumed via language hooks; avoid inline literals in components.
- When using discriminated unions (front or back), build/merge state via category-specific helpers so each branch matches its discriminator (e.g., `selectedCategory: 'Shot'` → `selectedAction: ShotResult`). Avoid “loose” object spreads that break the union and surface TS errors later.
- Apply Kent Beck/Fowler’s “Composed Method” with intention-revealing names: keep functions small and at a single level of abstraction so the main flow reads like prose. When a step drops abstraction, extract it to a helper with a “what, not how” name.

## Service and Repository Pattern (DIP)

Services MUST NOT import `prisma` directly. All database access goes through injected repositories.

### Service Constructor Pattern

```typescript
// ✅ CORRECT: Inject all required repositories
export class MatchService extends BaseService<Match> {
  constructor(
    private matchRepository: MatchRepository,
    private teamRepository: TeamRepository,
    private gameEventRepository: GameEventRepository,
  ) {
    super(matchRepository);
  }
}

// ❌ WRONG: Direct prisma import in service
import prisma from '../lib/prisma';
```

### Router Instantiation

Routes create services with all required repositories:

```typescript
const matchRepository = new MatchRepository();
const teamRepository = new TeamRepository();
const gameEventRepository = new GameEventRepository();

const service = new MatchService(matchRepository, teamRepository, gameEventRepository);
```

### Current Service Dependencies

| Service            | Required Repositories                                                      |
| ------------------ | -------------------------------------------------------------------------- |
| `MatchService`     | `MatchRepository`, `TeamRepository`, `GameEventRepository`                 |
| `TeamService`      | `TeamRepository`, `ClubRepository`, `SeasonRepository`, `PlayerRepository` |
| `GameEventService` | `GameEventRepository`, `MatchRepository`                                   |
| `ClubService`      | `ClubRepository`                                                           |
| `PlayerService`    | `PlayerRepository`                                                         |

## Testing Guidelines

- Suggested stack: Vitest or Jest with `ts-jest`/ESM support.
- Location: place tests under `tests/` mirroring `src/` structure; name as `*.spec.ts`.
- Coverage: target 80%+ lines/branches for new or modified code.
- Test data names: any club/team/season/player created by tests must start with `test-` to ease clean-up.
- Commands example: add `"test": "vitest"`, `"test:watch": "vitest --watch"` to `package.json`.

## Commit & Pull Request Guidelines

- Use Conventional Commits: `feat:`, `fix:`, `docs:`, `chore:`, `refactor:`, `test:`, `build:`.
- Limit subject to ~72 chars; include a concise body explaining rationale and impacts.
- PRs must include: clear description, linked issue (if any), before/after notes, and steps to verify (commands, endpoints).
- Keep PRs focused and small; include updates to docs/tests for changed behaviour.
- Push: the agent may run `git push` if the user explicitly asks.

## Architecture, SOLID, and TDD

To keep the project sustainable and easy to change and test, follow these concrete rules:

1. File structure and tests alongside code

- Keep tests near the code they cover. Ideal: tests next to the module (`src/module/x.ts` and `src/module/x.spec.ts` or `src/module/__tests__/x.spec.ts`). This eases refactors and ensures artefacts that change together live together.

2. SOLID and design patterns

- Follow SOLID to keep responsibilities clear. When a pattern improves separation of concerns or testability (e.g., Strategy to vary behaviours, Factory to create dependencies), use it and add a PR note explaining why.

3. Reuse and factorisation

- Avoid duplication: extract common utilities/components into reusable modules. Prefer composition over inheritance whenever possible.

4. TDD and coverage

- Work in TDD mode: write automated tests before implementing. Cover critical units and integration flows. For new or changed areas, target high coverage (recommended 85–90% for the affected area).

5. Test types and tooling

- Unit tests: Vitest for frontend and backend isolated code.
- Integration/API: Supertest + Vitest to validate routes and Prisma/DB integrations.
- E2E: add a solution when flows require it (optional).
- CI: ensure the pipeline runs `prisma generate` if needed and executes tests with the same setup as local (`npm ci && npm test`).

6. PRs and verification

- In the PR include: how to test locally, which tests were added, and a justification if a design pattern was applied. Do not close the PR until all tests pass and required coverage is met for modified files.

## Security & Configuration

- Configuration via env vars (e.g., `PORT`). Use a local `.env` and never commit secrets.
- Node 18+ recommended. Run `npm ci` for reproducible installs.
- Ignore generated artefacts in VCS (`dist/`, logs). Keep `src/` the single source of truth.

## Issue Templates & Follow-Up

- Templates:
  - Supertest: `.github/ISSUE_TEMPLATE/millora-supertest.md`
  - Husky + lint-staged: `.github/ISSUE_TEMPLATE/millora-husky-lint-staged.md`
- Use: on GitHub, New issue → pick the template, assign an owner, adjust acceptance criteria.

## Local Guides

- Folder `src/repositories/AGENTS.md`: specific instructions to optimise queries (use `select`, avoid deep `include`, add `select` tests).
- Folder `src/controllers/AGENTS.md`: validation with Zod, short methods, error handling, and injected dependencies.
- Folder `tests/AGENTS.md`: use of factories, query/wiring verification, validation coverage, and mocking patterns.
